// CAN Drivers

#include "CANBus.h"


/**
 * @brief Data structures needed for HAL CAN operation
 */
CAN_HandleTypeDef hcan2;
CAN_RxHeaderTypeDef RxHeader;
uint8_t RxData[8];
uint32_t TxMailbox;


/** MX CAN2 Init
  * @brief CAN2 Initialization Function
  * @note Generated by STMCube
  * 
  * @param mode CAN_MODE_NORMAL or CAN_MODE_LOOPBACK for operation mode
  * @return HAL_StatusTypeDef - Status of CAN initialization
  */
static HAL_StatusTypeDef MX_CAN2_Init(uint32_t mode) {
    hcan2.Instance = CAN2;
    hcan2.Init.Prescaler = 8;
    hcan2.Init.Mode = mode;  /* CAN_MODE_NORMAL or CAN_MODE_LOOPBACK */
    hcan2.Init.SyncJumpWidth = CAN_SJW_1TQ;
    hcan2.Init.TimeSeg1 = CAN_BS1_6TQ;
    hcan2.Init.TimeSeg2 = CAN_BS2_1TQ;
    hcan2.Init.TimeTriggeredMode = DISABLE;
    hcan2.Init.AutoBusOff = DISABLE;
    hcan2.Init.AutoWakeUp = DISABLE;
    hcan2.Init.AutoRetransmission = DISABLE;
    hcan2.Init.ReceiveFifoLocked = DISABLE;
    hcan2.Init.TransmitFifoPriority = DISABLE;

    return HAL_CAN_Init(&hcan2);
}


/** CAN Config
 * @brief Initialize CAN, configure CAN filters/interrupts, and start CAN
 * 
 * @param mode CAN_MODE_NORMAL or CAN_MODE_LOOPBACK for operation mode
 * @return HAL_StatusTypeDef - Status of CAN configuration
 */
HAL_StatusTypeDef CAN_Config(uint32_t mode) {
    HAL_StatusTypeDef configstatus = MX_CAN2_Init(mode);
    if (configstatus != HAL_OK) return configstatus;

    uint32_t RxFifo = CAN_RX_FIFO_NUMBER;
    
    CAN_FilterTypeDef filterconfig;
    filterconfig.FilterBank = FILTER_BANK;
    filterconfig.FilterMode = CAN_FILTERMODE_IDMASK;
    filterconfig.FilterScale = CAN_FILTERSCALE_32BIT;
    filterconfig.FilterIdLow = FILTER_ID_LOW;
    filterconfig.FilterIdHigh = FILTER_ID_HIGH;
    filterconfig.FilterMaskIdLow = FILTER_MASK_ID_LOW;
    filterconfig.FilterMaskIdHigh = FILTER_MASK_ID_HIGH;
    filterconfig.FilterFIFOAssignment = RxFifo;
    filterconfig.FilterActivation = CAN_FILTER_ENABLE;
    filterconfig.SlaveStartFilterBank = 14;

    // Setup filter
    configstatus = HAL_CAN_ConfigFilter(&hcan2, &filterconfig);
    if (configstatus != HAL_OK) return configstatus;

    // Start actual CAN
    configstatus = HAL_CAN_Start(&hcan2);
    if (configstatus != HAL_OK) return configstatus;

    // Enable interrupt for pending rx message
    configstatus = HAL_CAN_ActivateNotification(&hcan2, 
        (RxFifo == CAN_RX_FIFO0) ? 
            CAN_IT_RX_FIFO0_MSG_PENDING : CAN_IT_RX_FIFO1_MSG_PENDING);
    
    return configstatus;
}


/** CAN Transmit Message
 * @brief Transmit message over CAN
 * 
 * @param StdId Message ID (Standard)
 * @param TxData Data to transmit
 * @param len Length of data (Bytes) to transmit (MAX 8B)
 * @return HAL_StatusTypeDef - Status of CAN configuration
 */
HAL_StatusTypeDef CAN_TransmitMessage(
        uint32_t StdId,
        uint8_t *TxData,
        uint8_t len) {

    CAN_TxHeaderTypeDef txheader;

    // ExtID and extended mode are unused/not configured
    txheader.StdId = StdId;
    txheader.RTR = CAN_RTR_DATA;
    txheader.IDE = CAN_ID_STD;
    txheader.DLC = len;
    txheader.TransmitGlobalTime = DISABLE;

    return HAL_CAN_AddTxMessage(&hcan2, &txheader, TxData, &TxMailbox);
}

/**
 * @brief Function executed by interrupt when there is a pending message
 *        on RxFifo0
 */
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef* hcan) {
    HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &RxHeader, RxData);
}

/**
 * @brief Function executed by interrupt when there is a pending message
 *        on RxFifo1
 */
void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef* hcan) {
    HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO1, &RxHeader, RxData);
}