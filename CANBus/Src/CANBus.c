// CAN Drivers

#include "CANBus.h"
#include "config.h"
#include <string.h>

/**
 * @brief CAN recieve data buffers
 */
CANMSG_t BPS_AllClear, BPS_Trip, BPS_ContactorState;
CANMSG_t BPS_Voltage[NUM_BATTERY_MODULES];
CANMSG_t BPS_Temperature[NUM_TEMPERATURE_SENSORS];
CANMSG_t BPS_Current;

/**
 * @brief Data structures needed for HAL CAN operation
 */
static CAN_HandleTypeDef *HAL_CAN_2;
static CAN_RxHeaderTypeDef RxHeader;
static uint8_t RxData[8];
static uint32_t TxMailbox;


/** CAN Recieve
 * @brief Convert a raw CAN message to CANMSG_t and add to the RxFifo
 * 
 * @param header RxHeader from CAN message
 * @param data RxData from CAN message
 * @return HAL_StatusTypeDef - HAL_OK if message was parsed correctly
 * @return HAL_StatusTypeDef - HAL_ERROR if message ID does not match known IDs
 */
static HAL_StatusTypeDef CAN_Recieve(CAN_RxHeaderTypeDef *rx_header, uint8_t *rx_data) {
    CANMSG_t canmessage;
    CANMSG_t *messagedest = NULL;  // location to put message
    canmessage.id = rx_header->StdId;

    switch (canmessage.id) {
        // Messages to discard
        case WDOG_TRIGGERED:
        case CAN_ERROR:
        case CHARGE_ENABLE:
        case SOC_DATA:
            return HAL_ERROR;

        // Handle messages with one byte of data
        case TRIP:
            messagedest = &BPS_Trip;
        case ALL_CLEAR:
            if (messagedest == NULL) {
                messagedest = &BPS_AllClear;
            }
        case CONTACTOR_STATE:
            if (messagedest == NULL) {
                messagedest = &BPS_ContactorState;
            }
            memcpy(
                &(canmessage.payload.data.b),
                rx_data,
                sizeof(canmessage.payload.data.b));
            *messagedest = canmessage;
            break;

        // Handle messages with 4 byte data
        case CURRENT_DATA:
            memcpy(
                &(canmessage.payload.data.w),
                rx_data,
                sizeof(canmessage.payload.data.b));
            BPS_Current = canmessage;
            break;

        // Handle messages with idx + 4 byte data
        case VOLT_DATA:
            messagedest = BPS_Voltage;
        case TEMP_DATA:
            if (messagedest == NULL) {
                messagedest = BPS_Temperature;
            }
            canmessage.payload.idx = rx_data[0];
            memcpy(
                &(canmessage.payload.data.w),
                &(rx_data[1]),
                sizeof(canmessage.payload.data.w));
            messagedest[canmessage.payload.idx] = canmessage;
            break;

        // Handle invalid messages
        default:
            return HAL_ERROR;	// Do nothing if invalid
    }
    
    return HAL_OK;
}

/** MX CAN2 Init
  * @brief CAN2 Initialization Function
  * @note Generated by STMCube
  * 
  * @param mode CAN_MODE_NORMAL or CAN_MODE_LOOPBACK for operation mode
  * @return HAL_StatusTypeDef - Status of CAN initialization
  */
static HAL_StatusTypeDef MX_CAN2_Init(uint32_t mode) {
    HAL_CAN_2->Instance = CAN2;
    HAL_CAN_2->Init.Prescaler = 8;
    HAL_CAN_2->Init.Mode = mode;  /* CAN_MODE_NORMAL or CAN_MODE_LOOPBACK */
    HAL_CAN_2->Init.SyncJumpWidth = CAN_SJW_1TQ;
    HAL_CAN_2->Init.TimeSeg1 = CAN_BS1_6TQ;
    HAL_CAN_2->Init.TimeSeg2 = CAN_BS2_1TQ;
    HAL_CAN_2->Init.TimeTriggeredMode = DISABLE;
    HAL_CAN_2->Init.AutoBusOff = DISABLE;
    HAL_CAN_2->Init.AutoWakeUp = DISABLE;
    HAL_CAN_2->Init.AutoRetransmission = DISABLE;
    HAL_CAN_2->Init.ReceiveFifoLocked = DISABLE;
    HAL_CAN_2->Init.TransmitFifoPriority = DISABLE;

    return HAL_CAN_Init(HAL_CAN_2);
}


/** CAN Config
 * @brief Initialize CAN, configure CAN filters/interrupts, and start CAN
 * 
 * @param mode CAN_MODE_NORMAL or CAN_MODE_LOOPBACK for operation mode
 * @return HAL_StatusTypeDef - Status of CAN configuration
 */
HAL_StatusTypeDef CAN_Config(CAN_HandleTypeDef *hcan, uint32_t mode) {
    HAL_CAN_2 = hcan;
    HAL_StatusTypeDef configstatus = MX_CAN2_Init(mode);
    if (configstatus != HAL_OK) return configstatus;

    uint32_t RxFifo = CAN_RX_FIFO_NUMBER;
    
    CAN_FilterTypeDef filterconfig;
    filterconfig.FilterBank = FILTER_BANK;
    filterconfig.FilterMode = CAN_FILTERMODE_IDMASK;
    filterconfig.FilterScale = CAN_FILTERSCALE_32BIT;
    filterconfig.FilterIdLow = FILTER_ID_LOW;
    filterconfig.FilterIdHigh = FILTER_ID_HIGH;
    filterconfig.FilterMaskIdLow = FILTER_MASK_ID_LOW;
    filterconfig.FilterMaskIdHigh = FILTER_MASK_ID_HIGH;
    filterconfig.FilterFIFOAssignment = RxFifo;
    filterconfig.FilterActivation = CAN_FILTER_ENABLE;
    filterconfig.SlaveStartFilterBank = 14;

    // Setup filter
    configstatus = HAL_CAN_ConfigFilter(HAL_CAN_2, &filterconfig);
    if (configstatus != HAL_OK) return configstatus;

    // Start actual CAN
    configstatus = HAL_CAN_Start(HAL_CAN_2);
    if (configstatus != HAL_OK) return configstatus;

    // Enable interrupt for pending rx message
    configstatus = HAL_CAN_ActivateNotification(HAL_CAN_2, 
        (RxFifo == CAN_RX_FIFO0) ? 
            CAN_IT_RX_FIFO0_MSG_PENDING : CAN_IT_RX_FIFO1_MSG_PENDING);
    
    // Zero-out data buffers
    CANMSG_t emptymessage;
    emptymessage.payload.data.w = 0;
    
    emptymessage.id = ALL_CLEAR;
    BPS_AllClear = emptymessage;

    emptymessage.id = TRIP;
    BPS_Trip = emptymessage;

    emptymessage.id = CONTACTOR_STATE;
    BPS_ContactorState = emptymessage;

    emptymessage.id = CURRENT_DATA;
    BPS_Current = emptymessage;

    emptymessage.id = VOLT_DATA;
    for (uint8_t i = 0; i < NUM_BATTERY_MODULES; i++) {
        emptymessage.payload.idx = i;
        BPS_Voltage[i] = emptymessage;
    }
    
    emptymessage.id = TEMP_DATA;
    for (uint8_t i = 0; i < NUM_TEMPERATURE_SENSORS; i++) {
        emptymessage.payload.idx = i;
        BPS_Temperature[i] = emptymessage;
    }

    return configstatus;
}

/** CAN Transmit Message
 * @brief Transmit message over CAN
 * @note This is really basic and does not check for a full transmit Mailbox
 * 
 * @param StdId Message ID (Standard)
 * @param TxData Data to transmit
 * @param len Length of data (Bytes) to transmit (MAX 8B)
 * @return HAL_StatusTypeDef - Status of CAN configuration
 */
HAL_StatusTypeDef CAN_TransmitMessage(
        uint32_t StdId,
        uint8_t *TxData,
        uint8_t len) {

    CAN_TxHeaderTypeDef txheader;

    // ExtID and extended mode are unused/not configured
    txheader.StdId = StdId;
    txheader.RTR = CAN_RTR_DATA;
    txheader.IDE = CAN_ID_STD;
    txheader.DLC = len;
    txheader.TransmitGlobalTime = DISABLE;

    return HAL_CAN_AddTxMessage(HAL_CAN_2, &txheader, TxData, &TxMailbox);
}


/** CAN Retrieve Data
 * @brief Retrieve last-updated data recieved on CAN
 * @note Data can be:
 *          ALL_CLEAR, TRIP, CONTACTOR_STATE
 *          VOLT_DATA (all modules)
 *          TEMP_DATA (all modules)
 *          CURRENT_DATA
 * 
 * @param id (CANId_t) CAN ID of data to be fetched
 * @return CANMSG_t* pointer to data, will be array in the case of volt/temp
 */
CANMSG_t *CAN_RetrieveData(CANId_t id) {
    CANMSG_t *data_location;
    switch (id) {
        case TRIP:
            data_location = &BPS_Trip;
            break;
        case ALL_CLEAR:
            data_location = &BPS_AllClear;
            break;
        case CONTACTOR_STATE:
            data_location = &BPS_ContactorState;
            break;
        case VOLT_DATA:
            data_location = BPS_Voltage;
        case TEMP_DATA:
            data_location = BPS_Temperature;
        case CURRENT_DATA:
            data_location = &BPS_Current;
        default:
            data_location = NULL;
    }
    return data_location;
}

/**
 * @brief Function executed by interrupt when there is a pending message
 *        on RxFifo0
 */
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef* hcan) {
    HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &RxHeader, RxData);
    CAN_Recieve(&RxHeader, RxData);
}

/**
 * @brief Function executed by interrupt when there is a pending message
 *        on RxFifo1
 */
void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef* hcan) {
    HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO1, &RxHeader, RxData);
    CAN_Recieve(&RxHeader, RxData);
}